<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Neural Network Visualizer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overscroll-behavior: none;
        }
        .tooltip {
            position: absolute;
            text-align: center;
            padding: 6px 10px;
            font: 12px sans-serif;
            background: #2d3748;
            color: white;
            border: 0;
            border-radius: 8px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
        }
        .neuron-bias-text {
            font-size: 8px;
            fill: white;
            font-weight: bold;
            text-anchor: middle;
            pointer-events: none;
        }
        /* Custom scrollbar for kernel modal */
        #kernel-content::-webkit-scrollbar { width: 8px; }
        #kernel-content::-webkit-scrollbar-track { background: #e0e0e0; border-radius: 10px; }
        #kernel-content::-webkit-scrollbar-thumb { background: #a0a0a0; border-radius: 10px; }
        #kernel-content::-webkit-scrollbar-thumb:hover { background: #808080; }
    </style>
    <link rel="stylesheet" href="https://rsms.me/inter/inter.css">
</head>
<body class="bg-gray-100 text-gray-800 flex flex-col h-screen overflow-hidden">

    <!-- Header -->
    <header class="bg-white shadow-md p-4 z-20">
        <div class="container mx-auto flex justify-between items-center">
            <h1 class="text-2xl font-bold text-gray-700">Neural Network Visualizer</h1>
            <div class="flex items-center space-x-4">
                <label for="neuron-slider" class="text-sm font-medium text-gray-600 whitespace-nowrap">Max Neurons:</label>
                <input type="range" id="neuron-slider" min="10" max="250" value="50" class="w-48 h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                <span id="neuron-count" class="text-sm font-semibold text-gray-700 w-8 text-center">50</span>
            </div>
            <label for="file-input" class="cursor-pointer bg-blue-600 text-white font-semibold py-2 px-4 rounded-lg shadow hover:bg-blue-700 transition-colors">
                Load Model JSON
            </label>
            <input type="file" id="file-input" class="hidden" accept=".json">
        </div>
    </header>

    <!-- Main Content -->
    <main class="flex-grow relative" id="vis-container">
         <div id="placeholder" class="absolute inset-0 flex items-center justify-center text-gray-400">
            <div class="text-center">
                <svg xmlns="http://www.w3.org/2000/svg" class="mx-auto h-12 w-12" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" /></svg>
                <p class="mt-2 text-lg font-semibold">Upload a model JSON file to begin</p>
                <p class="text-sm">Use the Python script to export your `.h5` or `.keras` model.</p>
            </div>
        </div>
    </main>

    <!-- Tooltip -->
    <div id="tooltip" class="tooltip"></div>

    <!-- Kernel Details Modal -->
    <div id="kernel-modal" class="fixed inset-0 bg-black bg-opacity-50 z-50 hidden items-center justify-center p-4">
        <div class="bg-white rounded-lg shadow-2xl w-full max-w-3xl max-h-[80vh] flex flex-col">
            <div class="p-4 border-b flex justify-between items-center">
                <h2 class="text-xl font-bold">Convolutional Kernels</h2>
                <button id="close-modal" class="text-gray-500 hover:text-gray-800">&times;</button>
            </div>
            <div id="kernel-content" class="p-4 overflow-y-auto"></div>
        </div>
    </div>


    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const fileInput = document.getElementById('file-input');
            const visContainer = document.getElementById('vis-container');
            const placeholder = document.getElementById('placeholder');
            const tooltip = d3.select("#tooltip");
            const kernelModal = document.getElementById('kernel-modal');
            const kernelContent = document.getElementById('kernel-content');
            const closeModalBtn = document.getElementById('close-modal');
            const neuronSlider = document.getElementById('neuron-slider');
            const neuronCount = document.getElementById('neuron-count');

            let svg, g, zoom;
            let selectedNeuron = null;
            let selectedLayerIndex = -1;
            let selectedConnection = null;
            let modelData = null; 
            let maxNeuronsDisplay = 50;

            const LAYER_SPACING = 350;
            const NEURON_RADIUS = 10;
            const BLOCK_WIDTH = 120;
            const BLOCK_BASE_HEIGHT = 80;
            const ZOOM_CONNECTIONS_THRESHOLD = 1.2;

            // Initialize slider and value
            maxNeuronsDisplay = parseInt(neuronSlider.value, 10);
            neuronCount.textContent = maxNeuronsDisplay;

            neuronSlider.addEventListener('input', (event) => {
                maxNeuronsDisplay = parseInt(event.target.value, 10);
                neuronCount.textContent = maxNeuronsDisplay;
                if (modelData) {
                    drawNetwork(modelData); // Redraw if a model is loaded
                }
            });

            function initializeVisualization() {
                d3.select(visContainer).select('svg').remove();
                const { width, height } = visContainer.getBoundingClientRect();
                svg = d3.select(visContainer).append("svg")
                    .attr("width", width).attr("height", height)
                    .attr("viewBox", [0, 0, width, height])
                    .on("click", (event) => {
                        // Clicking on the background clears any selection
                        if (event.target.tagName === 'svg' || event.target.tagName === 'g') {
                            selectedNeuron = null;
                            selectedLayerIndex = -1;
                            selectedConnection = null;
                            g.selectAll(".neuron-bias-text").remove();
                            updateHighlighting(d3.zoomTransform(svg.node()));
                        }
                    });
                g = svg.append("g");
                zoom = d3.zoom().scaleExtent([0.1, 4]).on("zoom", zoomed);
                svg.call(zoom);
                window.addEventListener('resize', () => {
                    const { width, height } = visContainer.getBoundingClientRect();
                    svg.attr("width", width).attr("height", height).attr("viewBox", [0, 0, width, height]);
                });
            }

            fileInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (!file) return;
                placeholder.style.display = 'none';
                initializeVisualization();
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        modelData = JSON.parse(e.target.result);
                        drawNetwork(modelData);
                    } catch (error) {
                        console.error("Error parsing JSON file:", error);
                        placeholder.style.display = 'flex';
                        alert("Invalid JSON file. Please check the file format.");
                    }
                };
                reader.readAsText(file);
            });

            function zoomed({ transform }) {
                g.attr("transform", transform);
                updateHighlighting(transform);
            }

            function updateHighlighting(transform) {
                // Reset all highlights first
                g.selectAll(".neuron-group circle").attr("stroke", "#333").attr("stroke-width", 1.5);
                g.selectAll(".connection").style("stroke-opacity", 0).style("opacity", 0);
                g.selectAll(".connection-weight").style("opacity", 0);

                if (selectedConnection) {
                    // Highlight the single selected connection
                    const { source, target, line, text } = selectedConnection;
                    d3.select(line).style("stroke-opacity", 0.9).style("opacity", 1).attr("stroke-width", 4);
                    d3.select(text).style("opacity", 1);
                    d3.select(source.domNode).attr("stroke", "#000000").attr("stroke-width", 3);
                    d3.select(target.domNode).attr("stroke", "#000000").attr("stroke-width", 3);
                
                } else if (selectedNeuron) {
                    // Highlight all connections for the selected neuron
                    g.selectAll(`.connection-to-${selectedLayerIndex}-${selectedNeuron.index}, .connection-from-${selectedLayerIndex}-${selectedNeuron.index}`)
                        .style("stroke-opacity", 0.6).style("opacity", 1);
                    g.selectAll(`.weight-to-${selectedLayerIndex}-${selectedNeuron.index}, .weight-from-${selectedLayerIndex}-${selectedNeuron.index}`)
                        .style("opacity", 1);
                    d3.select(selectedNeuron.domNode).attr("stroke", "#000000").attr("stroke-width", 3);

                } else {
                    // Default visibility based on zoom level
                    const isZoomedIn = transform.k > ZOOM_CONNECTIONS_THRESHOLD;
                    g.selectAll(".connection").style("stroke-opacity", isZoomedIn ? 0.4 : 0.05).style("opacity", 1);
                    g.selectAll(".connection-weight").style("opacity", isZoomedIn ? 1 : 0);
                    g.selectAll(".connection-summary").style("stroke-opacity", 0.2);
                }
            }


            function drawNetwork(data) {
                g.selectAll("*").remove();
                const layers = data.config.layers;
                const weights = data.weights;
                let xOffset = 0;
                let layerNodes = [];

                layers.forEach((layer, i) => {
                    let currentLayerNodes;
                    if (['Dense', 'Input', 'Flatten'].includes(layer.type)) {
                         currentLayerNodes = drawDenseLayer(layer, data, i, xOffset);
                    } else {
                        currentLayerNodes = drawBlockLayer(layer, data, i, xOffset);
                    }
                    layerNodes.push({ type: layer.type, nodes: currentLayerNodes });
                    xOffset += LAYER_SPACING;
                });
                
                drawConnections(layers, weights, layerNodes);

                const { width, height } = visContainer.getBoundingClientRect();
                const graphBBox = g.node().getBBox();
                if(graphBBox.width > 0 && graphBBox.height > 0) {
                    const scale = Math.min(width / graphBBox.width, height / graphBBox.height) * 0.8;
                    const tx = (width - graphBBox.width * scale) / 2 - graphBBox.x * scale;
                    const ty = (height - graphBBox.height * scale) / 2 - graphBBox.y * scale;
                    svg.call(zoom.transform, d3.zoomIdentity.translate(tx, ty).scale(scale));
                }
            }
            
            function drawDenseLayer(layer, data, layerIndex, xOffset) {
                let numNeurons = 0;
                let biases = [];
                const allWeights = data.weights;

                if (layer.type === 'Input') {
                    const nextLayer = data.config.layers[layerIndex + 1];
                    if (nextLayer && allWeights[nextLayer.name] && nextLayer.type === 'Dense') {
                         numNeurons = allWeights[nextLayer.name].weights.length;
                    } else if (layer.shape && layer.shape.length > 0) {
                        numNeurons = layer.shape.reduce((a, b) => a * b, 1);
                    }
                } else if (layer.type === 'Flatten') {
                    if (layer.output_shape && layer.output_shape.length > 0) {
                        numNeurons = layer.output_shape.reduce((a, b) => a * b, 1);
                    }
                } else { // It's a Dense layer
                    numNeurons = layer.neurons;
                    biases = allWeights[layer.name].biases;
                }

                const neuronsToDisplay = Math.min(numNeurons, maxNeuronsDisplay);
                
                const nodes = d3.range(neuronsToDisplay).map(i => ({
                    x: xOffset,
                    y: (i - (neuronsToDisplay - 1) / 2) * (NEURON_RADIUS * 2.5),
                    bias: biases[i] || 0,
                    index: i
                }));
                
                const layerGroup = g.selectAll(`.layer-${xOffset.toFixed(0)}`).data(nodes).enter()
                    .append("g").attr("class", `neuron-group layer-${xOffset.toFixed(0)}`);

                layerGroup.append("circle")
                    .attr("cx", d => d.x).attr("cy", d => d.y).attr("r", NEURON_RADIUS)
                    .attr("fill", getLayerColor(layer.type)).attr("stroke", "#333").attr("stroke-width", 1.5)
                    .style("cursor", "pointer")
                    .on("mouseover", (event, d) => {
                        if (layer.type === 'Dense') {
                            tooltip.transition().duration(200).style("opacity", .9);
                            tooltip.html(`Bias: ${d.bias.toFixed(4)}`)
                                .style("left", `${event.pageX + 15}px`).style("top", `${event.pageY - 28}px`);
                        }
                    })
                    .on("mouseout", () => tooltip.transition().duration(500).style("opacity", 0))
                    .on("click", function(event, d) {
                        event.stopPropagation();
                        selectedConnection = null; // Clear connection selection
                        selectedNeuron = { ...d, domNode: this };
                        selectedLayerIndex = layerIndex;
                        
                        g.selectAll(".neuron-bias-text").remove();
                        if (layer.type === 'Dense') {
                            d3.select(this.parentNode).append("text")
                                .attr("class", "neuron-bias-text")
                                .attr("x", d.x).attr("y", d.y + 3)
                                .text(d.bias.toFixed(2));
                        }
                        updateHighlighting(d3.zoomTransform(svg.node()));
                    });

                if (numNeurons > neuronsToDisplay) {
                    const layerHeight = neuronsToDisplay * NEURON_RADIUS * 2.5;
                    g.append("text").attr("x", xOffset).attr("y", (layerHeight / 2) + 20)
                     .attr("text-anchor", "middle").style("font-size", "12px")
                     .text(`... (${numNeurons - neuronsToDisplay} more)`);
                }
                return layerGroup;
            }
            
            function drawBlockLayer(layer, data, layerIndex, xOffset) {
                const layerHeight = BLOCK_BASE_HEIGHT + (layer.filters || 0);
                const blockGroup = g.append("g")
                    .attr("transform", `translate(${xOffset}, 0)`)
                    .datum(layer);

                blockGroup.append("rect")
                    .attr("width", BLOCK_WIDTH).attr("height", layerHeight)
                    .attr("y", -layerHeight / 2).attr("rx", 8)
                    .attr("fill", getLayerColor(layer.type)).attr("stroke", "#333").attr("stroke-width", 1.5)
                    .style("cursor", layer.type === 'Conv2D' ? "pointer" : "default")
                    .on("click", (event, d) => {
                        if (d.type === 'Conv2D') displayKernels(data.weights[d.name]);
                    });
                
                blockGroup.append("text").attr("x", BLOCK_WIDTH / 2).attr("y", -5)
                    .attr("text-anchor", "middle").attr("font-weight", "bold").attr("fill", "white").text(layer.type);

                const infoText = blockGroup.append("text").attr("x", BLOCK_WIDTH / 2).attr("y", 15)
                    .attr("text-anchor", "middle").attr("fill", "white").style("font-size", "12px");

                infoText.append("tspan").attr("x", BLOCK_WIDTH / 2).attr("dy", "1.2em").text(getLayerInfo(layer));
                return blockGroup;
            }


            function drawConnections(layers, allWeights, layerNodes) {
                for (let i = 0; i < layers.length - 1; i++) {
                    const prevLayerConfig = layers[i];
                    const nextLayerConfig = layers[i + 1];
                    const prevNodes = layerNodes[i].nodes;
                    const nextNodes = layerNodes[i + 1].nodes;

                    if ((['Input', 'Dense', 'Flatten'].includes(prevLayerConfig.type)) && nextLayerConfig.type === 'Dense') {
                        const weights = allWeights[nextLayerConfig.name].weights;
                        
                        // Get the actual DOM elements for the circles
                        const sourceCircles = prevNodes.nodes().map(g => g.querySelector('circle'));
                        const targetCircles = nextNodes.nodes().map(g => g.querySelector('circle'));

                        prevNodes.data().forEach((sourceNode, sourceIdx) => {
                            nextNodes.data().forEach((targetNode, targetIdx) => {
                                if (weights && weights[sourceIdx] && weights[sourceIdx][targetIdx] !== undefined) {
                                    const weight = weights[sourceIdx][targetIdx];
                                    
                                    const line = g.append("line").lower()
                                        .attr("class", `connection connection-from-${i}-${sourceIdx} connection-to-${i+1}-${targetIdx}`)
                                        .attr("x1", sourceNode.x).attr("y1", sourceNode.y)
                                        .attr("x2", targetNode.x).attr("y2", targetNode.y)
                                        .attr("stroke", weight > 0 ? "#2563eb" : "#dc2626")
                                        .attr("stroke-width", Math.min(Math.abs(weight) * 2, 4))
                                        .style("stroke-opacity", 0.05);

                                    const text = g.append("text").lower()
                                        .attr("class", `connection-weight weight-from-${i}-${sourceIdx} weight-to-${i+1}-${targetIdx}`)
                                        .attr("x", (sourceNode.x + targetNode.x) / 2).attr("y", (sourceNode.y + targetNode.y) / 2)
                                        .attr("text-anchor", "middle").attr("dy", "-0.3em")
                                        .style("font-size", "10px").style("opacity", 0)
                                        .text(weight.toFixed(2));
                                    
                                    // Add a wider, transparent line for easier clicking
                                    g.append("line")
                                        .attr("x1", sourceNode.x).attr("y1", sourceNode.y)
                                        .attr("x2", targetNode.x).attr("y2", targetNode.y)
                                        .attr("stroke", "transparent").attr("stroke-width", 10)
                                        .style("cursor", "pointer")
                                        .on("click", function(event) {
                                            event.stopPropagation();
                                            selectedNeuron = null; // Clear neuron selection
                                            g.selectAll(".neuron-bias-text").remove();
                                            selectedConnection = {
                                                source: { ...sourceNode, domNode: sourceCircles[sourceIdx] },
                                                target: { ...targetNode, domNode: targetCircles[targetIdx] },
                                                line: line.node(),
                                                text: text.node()
                                            };
                                            updateHighlighting(d3.zoomTransform(svg.node()));
                                        });
                                }
                            });
                        });
                    } else { // Connections involving block layers
                        const sourceBBox = prevNodes.node().getBBox();
                        const targetBBox = nextNodes.node().getBBox();
                        if (!sourceBBox || !targetBBox || sourceBBox.width === 0 || targetBBox.width === 0) continue;
                        
                        let sourceX = sourceBBox.x + sourceBBox.width;
                        let sourceY = sourceBBox.y + sourceBBox.height / 2;
                        let targetX = targetBBox.x;
                        let targetY = targetBBox.y + targetBBox.height / 2;

                        g.append("line").lower()
                            .attr("class", "connection connection-summary")
                            .attr("x1", sourceX).attr("y1", sourceY).attr("x2", targetX).attr("y2", targetY)
                            .attr("stroke", "#6b7280").attr("stroke-width", 3).style("stroke-opacity", 0.2);
                    }
                }
            }

            function getLayerColor(type) {
                switch (type) {
                    case 'Input': return '#16a34a'; // Green
                    case 'Conv2D': return '#2563eb'; // Blue
                    case 'MaxPooling2D': case 'AveragePooling2D': return '#ca8a04'; // Amber
                    case 'Flatten': return '#9ca3af'; // Gray
                    case 'Dense': return '#db2777'; // Pink
                    default: return '#6b7280';
                }
            }
            function getLayerInfo(layer) {
                switch (layer.type) {
                    case 'Input': return `Shape: ${layer.shape.join('x')}`;
                    case 'Conv2D': return `${layer.filters} filters, ${layer.kernel_size.join('x')}`;
                    case 'MaxPooling2D': case 'AveragePooling2D': return `Pool: ${layer.pool_size.join('x')}`;
                    case 'Flatten': return `Outputs: ${layer.output_shape ? layer.output_shape[0] : 'N/A'}`;
                    default: return '';
                }
            }
            closeModalBtn.addEventListener('click', () => kernelModal.style.display = 'none');
            kernelModal.addEventListener('click', (e) => { if (e.target === kernelModal) kernelModal.style.display = 'none'; });
            function displayKernels(layerWeights) {
                kernelContent.innerHTML = '';
                const weights = layerWeights.weights; // [h, w, in_c, out_c]
                if(!weights || weights.length === 0) return;

                const filters = weights[0][0][0].length;
                const inChannels = weights[0][0].length;
                
                for (let f = 0; f < filters; f++) {
                    const filterDiv = document.createElement('div');
                    filterDiv.className = 'mb-6';
                    const title = document.createElement('h3');
                    title.className = 'text-lg font-semibold mb-2';
                    title.textContent = `Filter ${f + 1}`;
                    filterDiv.appendChild(title);
                    
                    const channelGrid = document.createElement('div');
                    channelGrid.className = 'grid gap-4';
                    channelGrid.style.gridTemplateColumns = `repeat(auto-fill, minmax(150px, 1fr))`;
                    
                    for (let c = 0; c < inChannels; c++) {
                        const channelDiv = document.createElement('div');
                        const channelTitle = document.createElement('p');
                        channelTitle.className = 'text-sm text-gray-600 mb-1';
                        channelTitle.textContent = `Input Channel ${c+1}`;
                        
                        const table = document.createElement('table');
                        table.className = 'border-collapse border border-gray-400';
                        const tbody = document.createElement('tbody');
                        
                        for(let h = 0; h < weights.length; h++) {
                            const row = document.createElement('tr');
                            for(let w = 0; w < weights[0].length; w++) {
                                const cell = document.createElement('td');
                                const value = weights[h][w][c][f];
                                cell.textContent = value.toFixed(3);
                                cell.className = 'border border-gray-300 p-1 text-center text-xs';
                                cell.style.backgroundColor = value > 0 ? `rgba(37, 99, 235, ${Math.min(Math.abs(value), 1)})` : `rgba(220, 38, 38, ${Math.min(Math.abs(value), 1)})`;
                                cell.style.color = Math.abs(value) > 0.5 ? 'white' : 'black';
                                row.appendChild(cell);
                            }
                            tbody.appendChild(row);
                        }
                        
                        table.appendChild(tbody);
                        channelDiv.appendChild(channelTitle);
                        channelDiv.appendChild(table);
                        channelGrid.appendChild(channelDiv);
                    }
                    filterDiv.appendChild(channelGrid);
                    kernelContent.appendChild(filterDiv);
                }
                kernelModal.style.display = 'flex';
            }
        });
    </script>
</body>
</html>

